{"mappings":"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","sources":["src/index.js","src/helpers.js"],"sourcesContent":["import { PKPWallet } from '@lit-protocol/pkp-ethers';\nimport { joinSignature } from '@ethersproject/bytes';\nimport { typedSignatureHash } from '@metamask/eth-sig-util';\nimport { convertHexToUtf8, getTransactionToSign } from './helpers.js';\nimport { ethers } from 'ethers';\n\n/**\n * The PKP class inherits PKPWallet Signer and adds the ability to respond to Ethereum JSON RPC signing requests.\n */\nclass LitPKP extends PKPWallet {\n  // -- Public methods --\n\n  /**\n   * Sign typed data with PKPWallet Signer\n   *\n   * @param {Object | string} msgParams message to sign\n   *\n   * @returns {Promise<string>} signature\n   */\n  async signTypedData(msgParams) {\n    const { types, domain, primaryType, message } = JSON.parse(msgParams);\n    if (types.EIP712Domain) {\n      delete types.EIP712Domain;\n    }\n    const signature = await this._signTypedData(domain, types, message);\n    return signature;\n  }\n\n  /**\n   * Handle legacy sign typed data (V1)\n   *\n   * @param {Object | string} msgParams message to sign\n   *\n   * @returns {Promise<string>} signature\n   */\n  async signTypedDataLegacy(msgParams) {\n    // https://github.com/MetaMask/eth-sig-util/blob/9f01c9d7922b717ddda3aa894c38fbba623e8bdf/src/sign-typed-data.ts#L435\n    const messageHash = typedSignatureHash(msgParams);\n    const sig = await this.runLitAction(\n      ethers.utils.arrayify(messageHash),\n      'sig1'\n    );\n    const encodedSig = joinSignature({\n      r: '0x' + sig.r,\n      s: '0x' + sig.s,\n      v: sig.recid,\n    });\n    return encodedSig;\n  }\n\n  /**\n   * Use PKPWallet Signer to sign Ethereum JSON-RPC API requests\n   *\n   * @param {Object} payload Ethereum JSON RPC payload\n   *\n   * @returns {(Promise<string> | Promise<Object>)} signed message, signed data, signed transaction, or sent transaction\n   */\n  async signEthereumRequest(payload) {\n    let address = ethers.utils.computeAddress(this.publicKey);\n    let addressRequested = null;\n    let message = null;\n    let msgParams = null;\n    let txParams = null;\n    let transaction = null;\n    let result = null;\n\n    switch (payload.method) {\n      case 'eth_sign':\n        addressRequested = payload.params[0];\n        if (address.toLowerCase() !== addressRequested.toLowerCase()) {\n          throw new Error('PKPWallet address does not match address requested');\n        }\n        message = convertHexToUtf8(payload.params[1]);\n        result = await this.signMessage(message);\n        break;\n      case 'personal_sign':\n        addressRequested = payload.params[1];\n        if (address.toLowerCase() !== addressRequested.toLowerCase()) {\n          throw new Error('PKPWallet address does not match address requested');\n        }\n        message = convertHexToUtf8(payload.params[0]);\n        result = await this.signMessage(message);\n        break;\n      case 'eth_signTypedData':\n        // Double check version to use since signTypedData can mean V1 (Metamask) or V3 (WalletConnect)\n        // References: https://docs.metamask.io/guide/signing-data.html#a-brief-history\n        // https://github.com/WalletConnect/walletconnect-monorepo/issues/546\n        if (ethers.utils.isAddress(payload.params[0])) {\n          // V3 or V4\n          addressRequested = payload.params[0];\n          if (address.toLowerCase() !== addressRequested.toLowerCase()) {\n            throw new Error(\n              'PKPWallet address does not match address requested'\n            );\n          }\n          msgParams = payload.params[1];\n          result = await this.signTypedData(msgParams);\n        } else {\n          // V1\n          addressRequested = payload.params[1];\n          if (address.toLowerCase() !== addressRequested.toLowerCase()) {\n            throw new Error(\n              'PKPWallet address does not match address requested'\n            );\n          }\n          msgParams = payload.params[0];\n          result = await this.signTypedDataLegacy(msgParams);\n        }\n        break;\n      case 'eth_signTypedData_v1':\n        // Params are flipped in V1 - https://medium.com/metamask/scaling-web3-with-signtypeddata-91d6efc8b290\n        addressRequested = payload.params[1];\n        if (address.toLowerCase() !== addressRequested.toLowerCase()) {\n          throw new Error('PKPWallet address does not match address requested');\n        }\n        msgParams = payload.params[0];\n        result = await this.signTypedDataLegacy(msgParams);\n        break;\n      case 'eth_signTypedData_v3':\n      case 'eth_signTypedData_v4':\n        addressRequested = payload.params[0];\n        if (address.toLowerCase() !== addressRequested.toLowerCase()) {\n          throw new Error('PKPWallet address does not match address requested');\n        }\n        msgParams = payload.params[1];\n        result = await this.signTypedData(msgParams);\n        break;\n      case 'eth_signTransaction':\n        txParams = payload.params[0];\n        addressRequested = txParams.from;\n        if (address.toLowerCase() !== addressRequested.toLowerCase()) {\n          throw new Error('PKPWallet address does not match address requested');\n        }\n        transaction = getTransactionToSign(txParams);\n        result = await this.signTransaction(transaction);\n        break;\n      case 'eth_sendTransaction': {\n        txParams = payload.params[0];\n        addressRequested = txParams.from;\n        if (address.toLowerCase() !== addressRequested.toLowerCase()) {\n          throw new Error('PKPWallet address does not match address requested');\n        }\n        transaction = getTransactionToSign(txParams);\n        const signedTx = await this.signTransaction(transaction);\n        result = await this.sendTransaction(signedTx);\n        break;\n      }\n      case 'eth_sendRawTransaction': {\n        transaction = payload.params[0];\n        result = await this.sendTransaction(transaction);\n        break;\n      }\n      default:\n        throw new Error(\n          `Ethereum JSON-RPC signing method \"${payload.method}\" is not supported`\n        );\n    }\n\n    return result;\n  }\n}\n\nfunction isSignRequestSupported(payload) {\n  const supportedMethods = [\n    'eth_sign',\n    'personal_sign',\n    'eth_signTypedData',\n    'eth_signTypedData_v1',\n    'eth_signTypedData_v3',\n    'eth_signTypedData_v4',\n    'eth_signTransaction',\n    'eth_sendTransaction',\n    'eth_sendRawTransaction',\n  ];\n  return supportedMethods.includes(payload.method);\n}\n\nexport { LitPKP, isSignRequestSupported };\n","import { ethers } from 'ethers';\n\nexport function convertHexToUtf8(value) {\n  try {\n    if (ethers.utils.isHexString(value)) {\n      return ethers.utils.toUtf8String(value);\n    }\n    return value;\n  } catch (e) {\n    return value;\n  }\n}\n\nexport const getTransactionToSign = txParams => {\n  let formattedTx = Object.assign({}, txParams);\n\n  if (formattedTx.gas) {\n    delete formattedTx.gas;\n  }\n\n  if (formattedTx.from) {\n    delete formattedTx.from;\n  }\n\n  return formattedTx;\n};\n"],"names":[],"version":3,"file":"main.js.map","sourceRoot":"../"}